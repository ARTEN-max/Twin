import OpenAI from 'openai';
import type { DebriefSection } from '@komuchi/shared';
import { getEnv } from '../env.js';

// ============================================
// Types
// ============================================

export type DebriefProvider = 'openai' | 'mock';

export interface DebriefResult {
  markdown: string;
  sections: DebriefSection[];
}

// Get the debrief provider from env
function getDebriefProvider(): DebriefProvider {
  const provider = process.env.DEBRIEF_PROVIDER || 'openai';
  if (provider !== 'openai' && provider !== 'mock') {
    console.warn(`Unknown DEBRIEF_PROVIDER "${provider}", defaulting to openai`);
    return 'openai';
  }
  return provider;
}

// NOTE: We intentionally do NOT enforce a fixed structured output schema here.
// The debrief is free-form markdown so it can adapt to the topic/content.

// ============================================
// System Prompts by Mode
// ============================================

const SYSTEM_PROMPTS: Record<string, string> = {
  general: `You are an expert conversation analyst.

Generate a debrief in Markdown. The format should be tailored to the topic and content of the transcript (do NOT force a fixed template).

Guidelines:
- Start with a short title and a brief summary (2â€“4 sentences).
- Choose the most relevant sections based on what happened (e.g., context, key moments, decisions, risks, outcomes, learnings).
- Include Action Items if any are implied (with owner if mentioned).
- Keep it scannable with headings and bullet points where appropriate.
- If the transcript is too short/low quality, say so and provide best-effort notes.`,

  meeting: `You are an expert meeting analyst.

Generate a debrief in Markdown tailored to this meeting (no fixed template).

Consider including (only if relevant):
- Objectives & outcomes
- Decisions
- Risks / blockers
- Open questions / parking lot
- Action items (owner + due date if present)
- Next steps`,

  sales: `You are an expert sales analyst.

Generate a debrief in Markdown tailored to this call (no fixed template).

Consider including (only if relevant):
- Customer context & pain points
- Objections & responses
- Value props / differentiation
- Competition
- Buying signals & risks
- Next steps / commitments
- Action items`,

  interview: `You are an expert interview analyst.

Generate a debrief in Markdown tailored to the interview (no fixed template).

Consider including (only if relevant):
- Strengths & evidence
- Gaps / risks
- Technical signals
- Communication & collaboration
- Culture signals
- Recommendation (if supported)
- Follow-up questions`,
};

// ============================================
// OpenAI Client
// ============================================

function getOpenAIClient(): OpenAI {
  const env = getEnv();
  return new OpenAI({
    apiKey: env.OPENAI_API_KEY,
  });
}

// ============================================
// Main Debrief Generation
// ============================================

/**
 * Generate a mock debrief for local development/testing
 */
async function generateMockDebrief(
  transcriptText: string,
  mode: string,
  title: string
): Promise<DebriefResult> {
  // Simulate API delay
  await new Promise((resolve) => setTimeout(resolve, 1000));

  console.log('âœ… Using mock debrief provider');

  const sections: DebriefSection[] = [
    {
      title: 'Key Discussion Points',
      content: `This is a mock debrief for "${title}".\n\nThe transcript contained ${transcriptText.length} characters discussing various topics related to ${mode}.`,
      order: 1,
    },
    {
      title: 'Decisions Made',
      content: '- Decision 1: Proceed with the current approach\n- Decision 2: Schedule follow-up meeting\n- Decision 3: Assign ownership to team leads',
      order: 2,
    },
    {
      title: 'Next Steps',
      content: '1. Review the discussed items\n2. Prepare action plan\n3. Share summary with stakeholders',
      order: 3,
    },
  ];

  const markdown = `# Debrief: ${title}

## Summary
This is a **mock debrief** generated for local development. In production, this would be generated by OpenAI GPT-4o analyzing the transcript.

## Mode
This recording was analyzed as a **${mode}** type.

## Key Discussion Points
${sections[0].content}

## Decisions Made
${sections[1].content}

## Next Steps
${sections[2].content}

## Action Items
- ðŸ”´ Review transcript and verify accuracy (High Priority)
- ðŸŸ¡ Share debrief with team members (Medium Priority)
- ðŸŸ¢ Archive recording for future reference (Low Priority)

---
*Note: This is mock data. Set \`DEBRIEF_PROVIDER=openai\` for real AI-generated debriefs.*
`;

  return {
    markdown,
    sections,
  };
}

/**
 * Generate a debrief from a transcript using OpenAI
 */
export async function generateDebrief(
  transcriptText: string,
  mode: string,
  title: string
): Promise<DebriefResult> {
  const provider = getDebriefProvider();

  if (provider === 'mock') {
    return generateMockDebrief(transcriptText, mode, title);
  }

  const client = getOpenAIClient();
  const systemPrompt = SYSTEM_PROMPTS[mode] || SYSTEM_PROMPTS.general;

  const response = await client.chat.completions.create({
    model: 'gpt-4o',
    messages: [
      {
        role: 'system',
        content: systemPrompt,
      },
      {
        role: 'user',
        content: `Transcript title: "${title}"\nMode: "${mode}"\n\nTranscript:\n${transcriptText}`,
      },
    ],
    temperature: 0.3, // Lower temperature for more consistent output
    max_tokens: 4000,
  });

  const content = response.choices[0]?.message?.content;
  if (!content) {
    throw new Error('No content in OpenAI response');
  }

  const markdown = content.trim();
  const sections = extractSectionsFromMarkdown(markdown);

  return {
    markdown,
    sections,
  };
}

/**
 * Extract sections from Markdown for DB storage.
 * We treat each `## Heading` as a section.
 */
function extractSectionsFromMarkdown(markdown: string): DebriefSection[] {
  const lines = markdown.split(/\r?\n/);
  const sections: DebriefSection[] = [];

  let currentTitle: string | null = null;
  let currentLines: string[] = [];

  const flush = () => {
    if (!currentTitle) return;
    sections.push({
      title: currentTitle,
      content: currentLines.join('\n').trim(),
      order: sections.length,
    });
    currentTitle = null;
    currentLines = [];
  };

  for (const line of lines) {
    const match = line.match(/^##\s+(.+)\s*$/);
    if (match) {
      flush();
      currentTitle = match[1].trim();
      continue;
    }
    if (currentTitle) currentLines.push(line);
  }
  flush();

  if (sections.length === 0) {
    return [{ title: 'Debrief', content: markdown.trim(), order: 0 }];
  }

  return sections;
}
